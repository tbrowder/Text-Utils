=begin pod

=head1 NAME

Text::Utils - Miscellaneous text utilities

=head1 SYNOPSIS

=begin code :lang<Raku>
# Export individual routines or :ALL
use Text::Utils :strip-comment;
my $text = q:to/HERE/;
    any kind of text, including code"; # some comment
    my $s = 'foo'; # another comment
    HERE

for $text.lines -> $line is copy {
    $line = strip-comment $line;
    say $line;
}
# OUTPUT:
any kind of text, including code;
my $s = 'foo';
=end code

=head1 DESCRIPTION

This module replaces the obsolete module 'Text::More' and
it should be an easy drop-in replacement.

The module contains several routines to make text handling
easier for module and program authors. Following is a short
synopsis and signature for each of the routines.

=head3 list2text

Turn a list into a text string for use in a document

For example, this list C<<1 2 3>> becomes either
this C<"1, 2, and 3"> (the default result) or this
C<"1, 2 and 3"> (if the C<$optional-comma> named variable
is set to false). The default result uses the so-called I<Oxford Comma>
which is not popular among some writers, but those authors
may change the default behavior by permanently by defining
the environment variable C<TEXT_UTILS_NO_OPTIONAL_COMMA>.

The signature:

=begin code :lang<Raku>
sub list2text(@list, :$optional-comma is copy = True) is export(:list2text) 
{...}
=end code

=item count-substrs

Count instances of a substring in a string

The signature:

=begin code :lang<Raku>
sub count-substrs(Str:D $ip, Str:D $substr --> UInt) is export(:count-substrs) 
{...}
=end code

=item strip-comments

Strip comments from an input text line, save comment if
requested, normalize returned text if requested

The routine returns a string of text with any comment stripped off. Note that the
designated char will trigger the strip even though it is
escaped or included in quotes.
Also returns the comment if requested.
All returned text is normalized if requested.

The signature:

=begin code :lang<Raku>
multi strip-comment($line is copy,       # string of text with possible comment
                    :$mark = '#',        # desired comment char indicator
                    :$save-comment,      # if true, return the comment
                    :$normalize,         # if true, normalize returned strings
                    :$last,              # if true, use the last instead of first comment char
                   ) is export(:strip-comment) 
{...}
=end code

=item commify

This routine is ported from the Perl version in the I<The Perl Cookbook, 3e>.

#| Purpose : Add commas to a number to separate multiples of a thousand
#| Params  : An integer or number with a decimal fraction
#| Returns : The input number with commas added, e.g.,
#|             1234.56 => 1,234.56
sub commify($num) is export(:commify) {
} # commify

#| Purpose : Wrap a list of words into a paragraph with a maximum line
#|             width (default: 78) and update the input list with the
#|           results
#| Params  : List of words, max line length, paragraph indent, first
#|             line indent, pre-text
#| Returns : List of formatted paragraph lines
multi write-paragraph(@text,
		      UInt :$max-line-length = 78,
                      UInt :$para-indent = 0,
		      UInt :$first-line-indent = 0,
                      Str :$pre-text = '' --> List) is export(:write-paragraph) {
} # write-paragraph

#| Purpose : Wrap a list of words into a paragraph with a maximum line
#|             width (default: 78) and print it to the input file handle
#| Params  : Output file handle, list of words, max line length,
#|             paragraph indent, first line indent, pre-text
#| Returns : Nothing
multi write-paragraph($fh, @text,
                      UInt :$max-line-length = 78,
                      UInt :$para-indent = 0,
                      UInt :$first-line-indent = 0,
                      Str :$pre-text = '') is export(:write-paragraph2) {
}

#| Purpose : Trim a string and collapse multiple whitespace characters
#|             to single ones
#| Returns : The normalized string
sub normalize-string(Str:D $str is copy --> Str) is export(:normalize-string) {
} # normalize-string

#| Purpose : Split a string into two pieces
#| Params  : String to be split, the split character, maximum length, a
#|             starting position for the search, search direction
#| Returns : The two parts of the split string; the second part will be
#|             empty string if the input string is not too long
sub split-line(Str:D $line is copy, Str:D $brk, UInt :$max-line-length = 0,
               UInt :$start-pos = 0, Bool :$rindex = False --> List) is export(:split-line) {
} # split-line

=item split-line-rw

Purpose: Split a string into two pieces
#| Params  : String to be split, the split character, maximum length, a
#|             starting position for the search, search direction
#| Returns : The part of the input string past the break character, or
#|             an empty string (the input string is modified in-place if
#|             it is too long)
=begin code
sub split-line-rw(Str:D $line is rw, 
                  Str:D $brk, 
                  UInt :$max-line-length = 0,
                  UInt :$start-pos = 0, 
                  Bool :$rindex = False --> Str) is export(:split-line-rw) 
{...}
=end code

=head1 AUTHOR

Tom Browder <tom.browder@gmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright &#x00A9; 2019-2020 Tom Browder

This library is free software; you can redistribute it or modify it under the Artistic License 2.0.

=end pod
